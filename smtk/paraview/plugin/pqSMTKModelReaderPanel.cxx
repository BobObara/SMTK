/*=========================================================================

 Program:   Visualization Toolkit
 Module:    $RCSfile: pqSMTKModelReaderPanel.cxx,v $

 =========================================================================*/
#include "pqSMTKModelReaderPanel.h"

#include "smtk/Qt/qtEntityItemDelegate.h"
#include "smtk/Qt/qtEntityItemModel.h"

#include "smtk/model/ImportJSON.h"
#include "smtk/model/ExportJSON.h"
#include "smtk/model/Storage.h"
#include "smtk/model/EntityPhrase.h"
#include "smtk/model/EntityListPhrase.h"
#include "smtk/model/SimpleModelSubphrases.h"

#include <QtGui/QApplication>
#include <QtGui/QTreeView>
#include <QtGui/QDockWidget>

#include <iomanip>
#include <iostream>
#include <fstream>

#include <stdlib.h>

#include <QPointer>
#include <QString>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QSizePolicy>
#include <QMessageBox>

#include <pqSMAdaptor.h>
#include "vtkEventQtSlotConnect.h"
#include "vtkSmartPointer.h"

using namespace std;

//-----------------------------------------------------------------------------
class pqSMTKModelReaderPanel::pqInternal
{
public:
  QPointer<QTreeView> ModelView;
  QPointer<QDockWidget> ModelDock;
  vtkSmartPointer<vtkEventQtSlotConnect> VTKConnect;
  bool ModelLoaded;

  pqInternal()
    {
    this->VTKConnect = vtkSmartPointer<vtkEventQtSlotConnect>::New();
    this->ModelLoaded = false;
    }
};

pqSMTKModelReaderPanel::pqSMTKModelReaderPanel(pqProxy* pxy, QWidget* p)
: pqAutoGeneratedObjectPanel(pxy, p)
{
  this->Internal = new pqSMTKModelReaderPanel::pqInternal();

  // Whenever the pipeline gets be updated, it's possible that the scalar ranges
  // change. If that happens, we try to ensure that the lookuptable range is big
  // enough to show the entire data (unless of course, the user locked the
  // lookuptable ranges).
  this->Internal->VTKConnect->Connect(
    this->proxy(), vtkCommand::UpdateDataEvent,
    this, SLOT(onDataUpdated()));

  QSizePolicy expandPolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  this->setSizePolicy(expandPolicy);

}

pqSMTKModelReaderPanel::~pqSMTKModelReaderPanel()
{
  delete this->Internal;
}

void pqSMTKModelReaderPanel::onDataUpdated()
{
  if(this->Internal->ModelLoaded)
    {
    return;
    }
  this->proxy()->UpdatePropertyInformation();
  std::string json = pqSMAdaptor::getElementProperty(this->proxy()->GetProperty(
                                          "JSONModel")).toString().toStdString();

  // QMessageBox::warning(NULL, "JSON Model",  json.c_str());
  smtk::model::BitFlags emask = smtk::model::MODEL_ENTITY;

  smtk::model::StoragePtr model = smtk::model::Storage::create();
  smtk::model::ImportJSON::intoModel(json.c_str(), model);
  model->assignDefaultNames();

  QPointer<smtk::model::QEntityItemModel> qmodel = new smtk::model::QEntityItemModel;
  QPointer<smtk::model::QEntityItemDelegate> qdelegate = new smtk::model::QEntityItemDelegate;
  // Make things fit inside tiny ParaView panel.
  qdelegate->setTitleFontSize(14);
  qdelegate->setSubtitleFontSize(10);
  qdelegate->setTitleFontWeight(1);
  qdelegate->setSubtitleFontWeight(1);
  if(!this->Internal->ModelDock)
    {
    this->Internal->ModelDock = new QDockWidget;
    this->Internal->ModelDock->setWindowTitle("SMTK Model");
    //QVBoxLayout* vLayout = new QVBoxLayout(this->Internal->ModelDock);
    this->Internal->ModelView = new QTreeView;
    QSizePolicy expandPolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    this->Internal->ModelView->setSizePolicy(expandPolicy);
    this->Internal->ModelDock->setWidget(this->Internal->ModelView);
    //this->Internal->ModelDock->setFloating(true);

     // Enable user sorting.
    this->Internal->ModelView->setSortingEnabled(true);

    QGridLayout* panelLayout = qobject_cast<QGridLayout*>(this->layout());
    if(panelLayout)
      {
      panelLayout->addWidget(this->Internal->ModelDock, panelLayout->rowCount()-1,0,1,
        panelLayout->columnCount());
      }
    else
      {
      this->layout()->addWidget(this->Internal->ModelDock);
      }
    }
  //cout << "emask " << hexconst(emask) << "\n";

  smtk::model::Cursors cursors;
  smtk::model::Cursor::CursorsFromUUIDs(
    cursors, model, model->entitiesMatchingFlags(emask, false));
  std::cout << std::setbase(10) << "Found " << cursors.size() << " entries\n";
  smtk::model::SimpleModelSubphrases::Ptr sgen = smtk::model::SimpleModelSubphrases::create();
  sgen->setAbridgeUses(true);
  qmodel->setRoot(
    smtk::model::EntityListPhrase::create()
      ->setup(cursors)
      ->setDelegate(sgen)); // set the subphrase generator:
  this->Internal->ModelView->setModel(qmodel); // must come after qmodel->setRoot()
  this->Internal->ModelView->setItemDelegate(qdelegate);
  this->Internal->ModelDock->show();

  this->Internal->ModelLoaded = true;
}

void pqSMTKModelReaderPanel::updateInformationAndDomains()
{
  this->Superclass::updateInformationAndDomains();
}

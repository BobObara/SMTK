/*=========================================================================

 Program:   Visualization Toolkit
 Module:    $RCSfile: pqSMTKModelReaderPanel.cxx,v $

 =========================================================================*/
#include "pqSMTKModelReaderPanel.h"

#include "smtk/Qt/qtEntityItemDelegate.h"
#include "smtk/Qt/qtEntityItemModel.h"
#include "smtk/Qt/qtModelView.h"

#include "smtk/model/ImportJSON.h"
#include "smtk/model/ExportJSON.h"
#include "smtk/model/Manager.h"
#include "smtk/model/EntityPhrase.h"
#include "smtk/model/EntityListPhrase.h"
#include "smtk/model/SimpleModelSubphrases.h"

#include <QtGui/QApplication>
#include <QtGui/QTreeView>
#include <QtGui/QDockWidget>

#include <iomanip>
#include <iostream>
#include <fstream>

#include <stdlib.h>

#include <QPointer>
#include <QString>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QSizePolicy>
#include <QMessageBox>

#include <pqSMAdaptor.h>
#include <pqDataRepresentation.h>
#include <pqPipelineSource.h>
#include <pqView.h>
#include <pqApplicationCore.h>
#include <pqObjectBuilder.h>
#include <pqSelectionManager.h>
#include <pqOutputPort.h>

#include "vtkEventQtSlotConnect.h"
#include "vtkSmartPointer.h"
#include "vtkPVSMTKModelInformation.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSessionProxyManager.h"
#include "vtkNew.h"
 #include "vtkSMSourceProxy.h"
 #include "vtkSMPropertyHelper.h"

using namespace std;
using namespace smtk::model;

//-----------------------------------------------------------------------------
class pqSMTKModelReaderPanel::pqInternal
{
public:
  QPointer<qtModelView> ModelView;
  QPointer<QDockWidget> ModelDock;
  vtkSmartPointer<vtkEventQtSlotConnect> VTKConnect;
  bool ModelLoaded;
  vtkNew<vtkPVSMTKModelInformation> ModelInfo;
  vtkSmartPointer<vtkSMProxy> SelectionSource;

  pqInternal()
    {
    this->VTKConnect = vtkSmartPointer<vtkEventQtSlotConnect>::New();
    this->ModelLoaded = false;
    }
};

pqSMTKModelReaderPanel::pqSMTKModelReaderPanel(pqProxy* pxy, QWidget* p)
: pqAutoGeneratedObjectPanel(pxy, p)
{
  this->Internal = new pqSMTKModelReaderPanel::pqInternal();

  // Whenever the pipeline gets be updated, it's possible that the scalar ranges
  // change. If that happens, we try to ensure that the lookuptable range is big
  // enough to show the entire data (unless of course, the user locked the
  // lookuptable ranges).
  this->Internal->VTKConnect->Connect(
    this->proxy(), vtkCommand::UpdateDataEvent,
    this, SLOT(onDataUpdated()));

  QSizePolicy expandPolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
  this->setSizePolicy(expandPolicy);

}

pqSMTKModelReaderPanel::~pqSMTKModelReaderPanel()
{
  delete this->Internal;
}

void pqSMTKModelReaderPanel::onDataUpdated()
{
  if(this->Internal->ModelLoaded)
    {
    return;
    }
  this->proxy()->UpdatePropertyInformation();
  std::string json = pqSMAdaptor::getElementProperty(this->proxy()->GetProperty(
                                          "JSONModel")).toString().toStdString();

  // QMessageBox::warning(NULL, "JSON Model",  json.c_str());
  smtk::model::BitFlags emask = smtk::model::MODEL_ENTITY | smtk::model::GROUP_ENTITY;

  smtk::model::ManagerPtr model = smtk::model::Manager::create();
  smtk::model::ImportJSON::intoModel(json.c_str(), model);
  model->assignDefaultNames();

  QPointer<smtk::model::QEntityItemModel> qmodel = new smtk::model::QEntityItemModel;
  QPointer<smtk::model::QEntityItemDelegate> qdelegate = new smtk::model::QEntityItemDelegate;
  // Make things fit inside tiny ParaView panel.
  qdelegate->setTitleFontSize(14);
  qdelegate->setSubtitleFontSize(10);
  qdelegate->setTitleFontWeight(1);
  qdelegate->setSubtitleFontWeight(1);
  if(!this->Internal->ModelDock)
    {
    this->Internal->ModelDock = new QDockWidget;
    this->Internal->ModelDock->setWindowTitle("SMTK Model");
    //QVBoxLayout* vLayout = new QVBoxLayout(this->Internal->ModelDock);
    this->Internal->ModelView = new qtModelView(this);
    QSizePolicy expandPolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    this->Internal->ModelView->setSizePolicy(expandPolicy);
    this->Internal->ModelDock->setWidget(this->Internal->ModelView);
    //this->Internal->ModelDock->setFloating(true);

     // Enable user sorting.
    this->Internal->ModelView->setSortingEnabled(true);

    QGridLayout* panelLayout = qobject_cast<QGridLayout*>(this->layout());
    if(panelLayout)
      {
      panelLayout->addWidget(this->Internal->ModelDock, panelLayout->rowCount()-1,0,1,
        panelLayout->columnCount());
      }
    else
      {
      this->layout()->addWidget(this->Internal->ModelDock);
      }
    QObject::connect(this->Internal->ModelView, SIGNAL(entitiesSelected(QList<smtk::util::UUID>)),
      this, SLOT(selectEntities(QList<smtk::util::UUID>)));


    }
  //cout << "emask " << hexconst(emask) << "\n";

  smtk::model::Cursors cursors;
  smtk::model::Cursor::CursorsFromUUIDs(
    cursors, model, model->entitiesMatchingFlags(emask, false));
  std::cout << std::setbase(10) << "Found " << cursors.size() << " entries\n";
  smtk::model::SimpleModelSubphrases::Ptr sgen = smtk::model::SimpleModelSubphrases::create();
  sgen->setAbridgeUses(true);
  qmodel->setRoot(
    smtk::model::EntityListPhrase::create()
      ->setup(cursors)
      ->setDelegate(sgen)); // set the subphrase generator:
  this->Internal->ModelView->setModel(qmodel); // must come after qmodel->setRoot()
  this->Internal->ModelView->setItemDelegate(qdelegate);
  this->Internal->ModelDock->show();

  this->Internal->ModelLoaded = true;
  this->proxy()->GatherInformation(this->Internal->ModelInfo.GetPointer());


  // create block selection source proxy
  vtkSMSessionProxyManager *proxyManager =
    vtkSMProxyManager::GetProxyManager()->GetActiveSessionProxyManager();

  this->Internal->SelectionSource.TakeReference(
    proxyManager->NewProxy("sources", "BlockSelectionSource"));
  pqPipelineSource* source = qobject_cast<pqPipelineSource*>(
    this->referenceProxy());
}


void pqSMTKModelReaderPanel::selectEntities(QList<smtk::util::UUID> selEntities)
{
  // create vector of selected block ids
  std::vector<vtkIdType> blockIds;
  foreach(smtk::util::UUID uuid, selEntities)
    {
    unsigned int flatIndex;
    if(this->Internal->ModelInfo->GetBlockId(uuid.toString(), flatIndex))
      {
      blockIds.push_back(flatIndex);
      }
    }

  vtkSMProxy* selectionSource = this->Internal->SelectionSource;

  // set selected blocks
  if (blockIds.size() > 0)
    {
    vtkSMPropertyHelper(selectionSource, "Blocks")
      .Set(&blockIds[0], static_cast<unsigned int>(blockIds.size()));
    }
  else
    {
    vtkSMPropertyHelper(selectionSource, "Blocks").SetNumberOfElements(0);
    }
  selectionSource->UpdateVTKObjects();

  vtkSMSourceProxy *selectionSourceProxy =
    vtkSMSourceProxy::SafeDownCast(selectionSource);
  pqPipelineSource* source = qobject_cast<pqPipelineSource*>(
    this->referenceProxy());
  pqOutputPort* outport = source->getOutputPort(0);
  if(outport)
    {
    outport->setSelectionInput(selectionSourceProxy, 0);
    }

  // update the selection manager
  pqSelectionManager *selectionManager =
    qobject_cast<pqSelectionManager*>(
      pqApplicationCore::instance()->manager("SelectionManager"));
  if(selectionManager && outport)
    {
    selectionManager->select(outport);
    }

  // delete the selection source
  // selectionSourceProxy->Delete();

  // update the views
  if(outport)
    {
    outport->renderAllViews();
    }

}

//-----------------------------------------------------------------------------
pqDataRepresentation* pqSMTKModelReaderPanel::getRepresentation()
{
  pqPipelineSource* source = qobject_cast<pqPipelineSource*>(
    this->referenceProxy());
  QList<pqView*> views = source->getViews();
  pqView* view = views.value(0);
  pqDataRepresentation* selfRep = source->getRepresentation(view);
  if(!selfRep)
    {
    pqObjectBuilder* builder = pqApplicationCore::instance()->getObjectBuilder();
    selfRep = builder->createDataRepresentation(source->getOutputPort(0), view);
    }
  return selfRep;
}

void pqSMTKModelReaderPanel::updateInformationAndDomains()
{
  this->Superclass::updateInformationAndDomains();
}

.. highlight:: c++
.. role:: cxx(code)
   :language: c++

.. role:: cmake(code)
   :language: cmake

.. _subclassing-bridge:

**************************
Creating a bridge subclass
**************************

Bridges exist to link foreign modeling entities to SMTK
modeling entities, in a bidirectional way:

* we *transcribe* foreign modeling entities into an SMTK model manager, and
* we perform *operations* in SMTK that make changes in the foreign modeling
  kernel (and then result in more transcriptions to update SMTK's model manager).

Only the first of these is needed for read-only access so we will cover it
first and then describe the interactions between bridges and operators.
:ref:`Implementing operators <tut - implement an operator>` is the topic
of a separate tutorial.

The first thing you must do when creating your own bridge is
to implement a subclass of :smtk:`smtk::model::Bridge`:

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.h
   :start-after: // ++ 1 ++
   :end-before: // -- 1 --

In the example above, some methods override the base
class in order to provide required functionality while others
just illustrate useful ways to divide tasks that should be
common to most bridges.

The first block of methods near the top of the declaration
are required in order for instances of the bridge to be
created and introspected by SMTK.

* The :smtk:`smtkDeclareModelingKernel` macro declares methods
  for introspection of the class.
  Bridge classes are managed by shared pointers and can be
  relatively heavyweight objects since they may contain maps
  from SMTK UUIDs to modeling kernel entities.

* The :cxx:`typedef smtk::shared_ptr<Bridge> Ptr` is required by some
  members declared in the :smtk:`smtkDeclareModelingKernel` macro.
  It is also useful for referencing shared pointers to the bridge
  internally.

* The :cxx:`typedef smtk::model::BridgedInfoBits BridgedInfoBits`
  is not required but will make implementing methods dealing with
  transcription of entities easier to type.

* The :cxx:`static BridgePtr create()` method is required in order
  for instances of the object to be created; its address is passed
  to the :smtk:`BridgeRegistrar` class by another macro discussed later
  so that instances of the bridge can be created given just a string
  describing the bridge.
  This is necessary so that bridges can be created and managed
  in remote processes.

* The virtual destructor should always be implemented so that the base
  class destructor is called.

* Finally, the :cxx:`allSupportedInformation` method exists so that SMTK
  can discover what types of information the bridge can provide to SMTK.
  The returned integer should be a bitwise OR of entries from
  the :smtk:`BridgedInformation` enum.
  For now, it is fine to return :smtk:`BRIDGE_EVERYTHING`.

The next step is to provide methods to access the maps between SMTK
and foreign entities (in this case, Exodus element blocks, side sets,
and node sets).
The :cxx:`toEntity` and :cxx:`toCursor` methods do this and will
be discussed in more detail in the next section.
Depending on your modeling kernel, you may use an existing type
from the foreign modeler (like the CGM bridge does) or a new class
like the :cxx:`EntityHandle` class in our example.

The final public methods, :cxx:`staticSetup` and :cxx:`setup`, exist
so that applications can set global configuration parameters on modeling
kernels using a consistent API.
The :cxx:`staticSetup` method should be called before an instance of
the bridge class is constructed and may be used to perform one-time
initialization of the modeling kernel.
The :cxx:`setup` method is invoked on a particular instance of a bridge
and is used to set things such as the tolerances used to tessellate
curved geometry in CGM.

Static initialization
---------------------

Now that we have declared the Exodus bridge class methods we must implement them.
In the :file:`Bridge.cxx` file, you will see that the :smtk:`smtkDeclareModelingKernel`
has a partner macro named :smtk:`smtkImplementsModelingKernel`, placed at the bottom
of the file **outside of any namespaces**:

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 1 ++
   :end-before: // -- 1 --

This macro takes 5 parameters:

1. A "short" name for the bridge. This is used as part of some variable names inside the macro,
   so you should not use punctuation other than underscores.
   The short name ("exodus") will be used as the string name for the bridge and
   in other macros like :smtk:`smtkComponentInitMacro` when you name the bridge
   as a component to be initialized at link-time.

2. A string containing a valid JSON dictionary describing the capabilities of the bridge.
   We pass the argument :cxx:`Bridge_json`, which is defined in the :file:`Bridge_json.h`
   header file.
   The header is generated by the CMake :cmake:`smtk_bridge_json` macro,
   which simply encodes the contents of a JSON file as a C string for your convenience.
   The Exodus bridge has the following description:

   .. literalinclude:: ../../../smtk/bridge/exodus/Bridge.json

   At a minimum, the JSON dictionary must include

   + The name of the bridge. This should match the "short" name passed to :smtk:`smtkImplementsModelingKernel`.
   + A list of modeling engines that the kernel supports and the capabilities of each.
     If your bridge only supports a single modeling engine, use the name "default" as the Exodus bridge does.
     At a minimum, the capabilities for each engine should include a list of
     file extensions that the bridge can read.

3. An :cxx:`smtk::function` to be invoked with any configuration parameters
   before an instance of the bridge is created.
   The function should take two arguments:
   a :smtk:`String` parameter name and
   a :smtk:`StringList` parameter value.
   If you do not have any static configuration parameters, then
   simply pass :smtk:`BridgeHasNoStaticSetup`.
   The CGM bridge provides an implementation of this to set the default
   modeling kernel engine (e.g., to either OpenCascade or ACIS) since the
   engine should be prepared before the bridge is constructed.
   Otherwise, the modeling operations listed in the bridge's
   attribute system might not reflect those available for the engine
   being used.

4. The fully-qualified name of the bridge class, including namespaces.

5. Either :cxx:`true` or :cxx:`false`, used to indicate whether the
   bridge should inherit operators from its subclass.
   You should pass true unless your bridge is a "forwarding" bridge
   (i.e., one that forwards operations to a remote process rather than
   performing them locally).

Bridge constructor
------------------

Besides the macro declaration, your constructor **must** provide
the base class with the place it stores information
about bridge-specific operators:

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 2 ++
   :end-before: // -- 2 --

The :smtk:`Bridge::initializeOperatorSystem` method creates
a new attribute :smtk:`System` and populates it with all the
operators in the given :cxx:`Bridge::s_operators` member,
which is declared by the :cxx:`smtkDeclareModelingKernel` macro
and instantiated by the :cxx:`smtkImplementsModelingKernel` macro.
This allows bridge-specific operators to be statically initialized and
registered at link-time.
The :cxx:`Bridge::s_operators` member is populated with operators by calls to
the :smtk:`smtkImplementsModelOperator` macro inside each operator's
implementation.

Transcribing entities
---------------------

The main purpose of the bridge is to provide the SMTK model Manager
which owns it with information about the entities in some foreign modeler
and the :smtk:`Bridge::transcribeInternal` method is where your bridge
must do this.

The first thing you should do is verify that the entity being requested
actually exists:

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 7 ++
   :end-before: // -- 7 --

One trick you'll see in most bridges is the construction of a "mutable" cursor
from the const version that passed to :cxx:`transcribeInternal`:

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 8 ++
   :end-before: // -- 8 --

The const version does not provide access to methods that alter the model manager's storage.
Constructing a mutable version of the cursor is legitimate inside the bridge â€”
we are pretending that the entity to be transcribed has existed in the manager
ever since it existed in the foreign modeler.
Since transcription should not change the entity in the foreign modeler,
creating a mutable cursor is acceptable.

Once you know that the UUID has a matching entity in the foreign modeler,
you should create an :smtk:`Entity` instance in the model manager's map
from UUIDs to entities.
Make sure that the entity's flags properly define the type of the entity
at this point but don't worry about filling in the list of relations to
other entities unless the :smtk:`BRIDGE_ENTITY_RELATIONS` bit is set
in the request for transcription.

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 9 ++
   :end-before: // -- 9 --

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 10 ++
   :end-before: // -- 10 --

If :smtk:`BRIDGE_ENTITY_RELATIONS` is set, then you not only need to
ensure that the relations are listed but that they are also *at least*
partially transcribed.
You are always welcome to transcribe more than is requested,
but be aware that this can slow things down for large models.
Because this is an example and because the Exodus bridge does not
expose individual cells as first-class entities,
we transcribe the entire model recursively.

.. literalinclude:: ../../../smtk/bridge/exodus/Bridge.cxx
   :start-after: // ++ 11 ++
   :end-before: // -- 11 --

Now you should check other bits in :smtk:`BridgedInformation` that
are present in your :smtk:`Bridge::allSupportedInformation` method
and ensure that information is transcribed properly before returning
the bits which were actually transcribed for the given entity.

The :smtk:`Bridge::transcribe` method uses the return value to
update its list of dangling (partially transcribed) entities.
